<?xml version='1.0' encoding='utf-8'?>

<chapter xml:id="ch-survival-analysis" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Survival Analysis</title>

  <introduction>
    <p>
      You can order print and ebook versions of <em>Think Bayes 2e</em> from <url href="https://bookshop.org/a/98697/9781492089469">Bookshop.org</url> and <url href="https://amzn.to/334eqGo">Amazon</url>.
    </p>
    <program language="python">
      <input>
# install empiricaldist if necessary

try:
    import empiricaldist
except ImportError:
    !pip install empiricaldist
    import empiricaldist
      </input>
    </program>
    <program language="python">
      <input>
# Get utils.py

from os.path import basename, exists

def download(url):
    filename = basename(url)
    if not exists(filename):
        from urllib.request import urlretrieve
        local, _ = urlretrieve(url, filename)
        print('Downloaded ' + local)
    
download('https://github.com/AllenDowney/ThinkBayes2/raw/master/soln/utils.py')
      </input>
    </program>
    <program language="python">
      <input>
from utils import set_pyplot_params
set_pyplot_params()
      </input>
    </program>
    <p>
      This chapter introduces "survival analysis", which is a set of statistical methods used to answer questions about the time until an event. In the context of medicine it is literally about survival, but it can be applied to the time until any kind of event, or instead of time it can be about space or other dimensions.
    </p>
    <p>
      Survival analysis is challenging because the data we have are often incomplete.  But as we'll see, Bayesian methods are particularly good at working with incomplete data.
    </p>
    <p>
      As examples, we'll consider two applications that are a little less serious than life and death: the time until light bulbs fail and the time until dogs in a shelter are adopted. To describe these "survival times", we'll use the Weibull distribution.
    </p>
  </introduction>

  <section xml:id="sec-the-weibull-distribution">
    <title>The Weibull Distribution</title>

    <p>
      The <url href="https://en.wikipedia.org/wiki/Weibull_distribution">Weibull distribution</url> is often used in survival analysis because it is a good model for the distribution of lifetimes for manufactured products, at least over some parts of the range.
    </p>
    <p>
      SciPy provides several versions of the Weibull distribution; the one we'll use is called <c>weibull_min</c>. To make the interface consistent with our notation, I'll wrap it in a function that takes as parameters <m>\lambda</m>, which mostly affects the location or "central tendency" of the distribution, and <m>k</m>, which affects the shape.
    </p>
    <program language="python">
      <input>
from scipy.stats import weibull_min

def weibull_dist(lam, k):
    return weibull_min(k, scale=lam)
      </input>
    </program>
    <p>
      As an example, here's a Weibull distribution with parameters <m>\lambda=3</m> and <m>k=0.8</m>.
    </p>
    <program language="python">
      <input>
lam = 3
k = 0.8
actual_dist = weibull_dist(lam, k)
      </input>
    </program>
    <p>
      The result is an object that represents the distribution. Here's what the Weibull CDF looks like with those parameters.
    </p>
    <program language="python">
      <input>
import numpy as np
from empiricaldist import Cdf
from utils import decorate

qs = np.linspace(0, 12, 101)
ps = actual_dist.cdf(qs)
cdf = Cdf(ps, qs)
cdf.plot()

decorate(xlabel='Duration in time', 
         ylabel='CDF',
         title='CDF of a Weibull distribution')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_43e61ec5.png" width="80%"/>
    <p>
      <c>actual_dist</c> provides <c>rvs</c>, which we can use to generate a random sample from this distribution.
    </p>
    <program language="python">
      <input>
np.random.seed(17)
      </input>
    </program>
    <program language="python">
      <input>
data = actual_dist.rvs(10)
data
      </input>
    </program>
<pre>
array([0.80497283, 2.11577082, 0.43308797, 0.10862644, 5.17334866,
       3.25745053, 3.05555883, 2.47401062, 0.05340806, 1.08386395])
</pre>
    <p>
      So, given the parameters of the distribution, we can generate a sample. Now let's see if we can go the other way: given the sample, we'll estimate the parameters.
    </p>
    <p>
      Here's a uniform prior distribution for <m>\lambda</m>:
    </p>
    <program language="python">
      <input>
from utils import make_uniform

lams = np.linspace(0.1, 10.1, num=101)
prior_lam = make_uniform(lams, name='lambda')
      </input>
    </program>
    <p>
      And a uniform prior for <m>k</m>:
    </p>
    <program language="python">
      <input>
ks = np.linspace(0.1, 5.1, num=101)
prior_k = make_uniform(ks, name='k')
      </input>
    </program>
    <p>
      I'll use <c>make_joint</c> to make a joint prior distribution for the two parameters.
    </p>
    <program language="python">
      <input>
from utils import make_joint

prior = make_joint(prior_lam, prior_k)
      </input>
    </program>
    <p>
      The result is a <c>DataFrame</c> that represents the joint prior, with possible values of <m>\lambda</m> across the columns and values of <m>k</m> down the rows.
    </p>
    <p>
      Now I'll use <c>meshgrid</c> to make a 3-D mesh with <m>\lambda</m> on the first axis (<c>axis=0</c>), <m>k</m> on the second axis (<c>axis=1</c>), and the data on the third axis (<c>axis=2</c>).
    </p>
    <program language="python">
      <input>
lam_mesh, k_mesh, data_mesh = np.meshgrid(
    prior.columns, prior.index, data)
      </input>
    </program>
    <p>
      Now we can use <c>weibull_dist</c> to compute the PDF of the Weibull distribution for each pair of parameters and each data point.
    </p>
    <program language="python">
      <input>
densities = weibull_dist(lam_mesh, k_mesh).pdf(data_mesh)
densities.shape
      </input>
    </program>
<pre>
(101, 101, 10)
</pre>
    <p>
      The likelihood of the data is the product of the probability densities along <c>axis=2</c>.
    </p>
    <program language="python">
      <input>
likelihood = densities.prod(axis=2)
likelihood.sum()
      </input>
    </program>
<pre>
2.0938302958838208e-05
</pre>
    <p>
      Now we can compute the posterior distribution in the usual way.
    </p>
    <program language="python">
      <input>
from utils import normalize

posterior = prior * likelihood
normalize(posterior)
      </input>
    </program>
<pre>
2.052573567183434e-09
</pre>
    <p>
      The following function encapsulates these steps. It takes a joint prior distribution and the data, and returns a joint posterior distribution.
    </p>
    <program language="python">
      <input>
def update_weibull(prior, data):
    &quot;&quot;&quot;Update the prior based on data.&quot;&quot;&quot;
    lam_mesh, k_mesh, data_mesh = np.meshgrid(
        prior.columns, prior.index, data)
    
    densities = weibull_dist(lam_mesh, k_mesh).pdf(data_mesh)
    likelihood = densities.prod(axis=2)

    posterior = prior * likelihood
    normalize(posterior)

    return posterior
      </input>
    </program>
    <p>
      Here's how we use it.
    </p>
    <program language="python">
      <input>
posterior = update_weibull(prior, data)
      </input>
    </program>
    <p>
      And here's a contour plot of the joint posterior distribution.
    </p>
    <program language="python">
      <input>
from utils import plot_contour

plot_contour(posterior)
decorate(title='Posterior joint distribution of Weibull parameters')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_319f30c9.png" width="80%"/>
    <p>
      It looks like the range of likely values for <m>\lambda</m> is about 1 to 4, which contains the actual value we used to generate the data, 3. And the range for <m>k</m> is about 0.5 to 1.5, which contains the actual value, 0.8.
    </p>
  </section>

  <section xml:id="sec-marginal-distributions">
    <title>Marginal Distributions</title>

    <p>
      To be more precise about these ranges, we can extract the marginal distributions:
    </p>
    <program language="python">
      <input>
from utils import marginal

posterior_lam = marginal(posterior, 0)
posterior_k = marginal(posterior, 1)
      </input>
    </program>
    <p>
      And compute the posterior means and 90% credible intervals.
    </p>
    <program language="python">
      <input>
import matplotlib.pyplot as plt

plt.axvline(3, color='C5')
posterior_lam.plot(color='C4', label='lambda')
decorate(xlabel='lam',
         ylabel='PDF', 
         title='Posterior marginal distribution of lam')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_ab5edebf.png" width="80%"/>
    <p>
      The vertical gray line show the actual value of <m>\lambda</m>.
    </p>
    <p>
      Here's the marginal posterior distribution for <m>k</m>.
    </p>
    <program language="python">
      <input>
plt.axvline(0.8, color='C5')
posterior_k.plot(color='C12', label='k')
decorate(xlabel='k',
         ylabel='PDF', 
         title='Posterior marginal distribution of k')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_fb78d6bb.png" width="80%"/>
    <p>
      The posterior distributions are wide, which means that with only 10 data points we can't estimated the parameters precisely. But for both parameters, the actual value falls in the credible interval.
    </p>
    <program language="python">
      <input>
print(lam, posterior_lam.credible_interval(0.9))
      </input>
    </program>
<pre>
3 [1.2 4.4]
</pre>
    <program language="python">
      <input>
print(k, posterior_k.credible_interval(0.9))
      </input>
    </program>
<pre>
0.8 [0.6 1.4]
</pre>
  </section>

  <section xml:id="sec-incomplete-data">
    <title>Incomplete Data</title>

    <p>
      In the previous example we were given 10 random values from a Weibull distribution, and we used them to estimate the parameters (which we pretended we didn't know).
    </p>
    <p>
      But in many real-world scenarios, we don't have complete data; in particular, when we observe a system at a point in time, we generally have information about the past, but not the future.
    </p>
    <p>
      As an example, suppose you work at a dog shelter and you are interested in the time between the arrival of a new dog and when it is adopted. Some dogs might be snapped up immediately; others might have to wait longer. The people who operate the shelter might want to make inferences about the distribution of these residence times.
    </p>
    <p>
      Suppose you monitor arrivals and departures over 8 weeks and 10 dogs arrive during that interval. I'll assume that their arrival times are distributed uniformly, so I'll generate random values like this.
    </p>
    <program language="python">
      <input>
np.random.seed(19)
      </input>
    </program>
    <program language="python">
      <input>
start = np.random.uniform(0, 8, size=10)
start
      </input>
    </program>
<pre>
array([0.78026881, 6.08999773, 1.97550379, 1.1050535 , 2.65157251,
       0.66399652, 5.37581665, 6.45275039, 7.86193532, 5.08528588])
</pre>
    <p>
      Now let's suppose that the residence times follow the Weibull distribution we used in the previous example. We can generate a sample from that distribution like this:
    </p>
    <program language="python">
      <input>
np.random.seed(17)
      </input>
    </program>
    <program language="python">
      <input>
duration = actual_dist.rvs(10)
duration
      </input>
    </program>
<pre>
array([0.80497283, 2.11577082, 0.43308797, 0.10862644, 5.17334866,
       3.25745053, 3.05555883, 2.47401062, 0.05340806, 1.08386395])
</pre>
    <p>
      I'll use these values to construct a <c>DataFrame</c> that contains the arrival and departure times for each dog, called <c>start</c> and <c>end</c>.
    </p>
    <program language="python">
      <input>
import pandas as pd

d = dict(start=start, end=start+duration)
obs = pd.DataFrame(d)
      </input>
    </program>
    <p>
      For display purposes, I'll sort the rows of the <c>DataFrame</c> by arrival time.
    </p>
    <program language="python">
      <input>
obs = obs.sort_values(by='start', ignore_index=True)
obs
      </input>
    </program>
<pre>
start       end
0  0.663997  3.921447
1  0.780269  1.585242
2  1.105053  1.213680
3  1.975504  2.408592
4  2.651573  7.824921
5  5.085286  6.169150
6  5.375817  8.431375
7  6.089998  8.205769
8  6.452750  8.926761
9  7.861935  7.915343
</pre>
    <p>
      Notice that several of the lifelines extend past the observation window of 8 weeks. So if we observed this system at the beginning of Week 8, we would have incomplete information. Specifically, we would not know the future adoption times for Dogs 6, 7, and 8.
    </p>
    <p>
      I'll simulate this incomplete data by identifying the lifelines that extend past the observation window:
    </p>
    <program language="python">
      <input>
censored = obs['end'] &gt; 8
      </input>
    </program>
    <p>
      <c>censored</c> is a  Boolean Series that is <c>True</c> for lifelines that extend past Week 8.
    </p>
    <p>
      Data that is not available is sometimes called "censored" in the sense that it is hidden from us. But in this case it is hidden because we don't know the future, not because someone is censoring it.
    </p>
    <p>
      For the lifelines that are censored, I'll modify <c>end</c> to indicate when they are last observed and <c>status</c> to indicate that the observation is incomplete.
    </p>
    <program language="python">
      <input>
obs.loc[censored, 'end'] = 8
obs.loc[censored, 'status'] = 0
      </input>
    </program>
    <p>
      Now we can plot a "lifeline" for each dog, showing the arrival and departure times on a time line.
    </p>
    <program language="python">
      <input>
def plot_lifelines(obs):
    &quot;&quot;&quot;Plot a line for each observation.
    
    obs: DataFrame
    &quot;&quot;&quot;
    for y, row in obs.iterrows():
        start = row['start']
        end = row['end']
        status = row['status']
        
        if status == 0:
            # ongoing
            plt.hlines(y, start, end, color='C0')
        else:
            # complete
            plt.hlines(y, start, end, color='C1')
            plt.plot(end, y, marker='o', color='C1')
            
    decorate(xlabel='Time (weeks)',
             ylabel='Dog index',
             title='Lifelines showing censored and uncensored observations')

    plt.gca().invert_yaxis()
      </input>
    </program>
    <program language="python">
      <input>
plot_lifelines(obs)
      </input>
    </program>
    <image source="images/ch14_survival_analysis_653c218b.png" width="80%"/>
    <p>
      And I'll add one more column to the table, which contains the duration of the observed parts of the lifelines.
    </p>
    <program language="python">
      <input>
obs['T'] = obs['end'] - obs['start']
      </input>
    </program>
    <p>
      What we have simulated is the data that would be available at the beginning of Week 8.
    </p>
  </section>

  <section xml:id="sec-using-incomplete-data">
    <title>Using Incomplete Data</title>

    <p>
      Now, let's see how we can use both kinds of data, complete and incomplete, to infer the parameters of the distribution of residence times.
    </p>
    <p>
      First I'll split the data into two sets: <c>data1</c> contains residence times for dogs whose arrival and departure times are known; <c>data2</c> contains incomplete residence times for dogs who were not adopted during the observation interval.
    </p>
    <program language="python">
      <input>
data1 = obs.loc[~censored, 'T']
data2 = obs.loc[censored, 'T']
      </input>
    </program>
    <program language="python">
      <input>
data1
      </input>
    </program>
<pre>
0    3.257451
1    0.804973
2    0.108626
3    0.433088
4    5.173349
5    1.083864
9    0.053408
Name: T, dtype: float64
</pre>
    <program language="python">
      <input>
data2
      </input>
    </program>
<pre>
6    2.624183
7    1.910002
8    1.547250
Name: T, dtype: float64
</pre>
    <p>
      For the complete data, we can use <c>update_weibull</c>, which uses the PDF of the Weibull distribution to compute the likelihood of the data.
    </p>
    <program language="python">
      <input>
posterior1 = update_weibull(prior, data1)
      </input>
    </program>
    <p>
      For the incomplete data, we have to think a little harder. At the end of the observation interval, we don't know what the residence time will be, but we can put a lower bound on it; that is, we can say that the residence time will be greater than <c>T</c>.
    </p>
    <p>
      And that means that we can compute the likelihood of the data using the survival function, which is the probability that a value from the distribution exceeds <c>T</c>.
    </p>
    <p>
      The following function is identical to <c>update_weibull</c> except that it uses <c>sf</c>, which computes the survival function, rather than <c>pdf</c>.
    </p>
    <program language="python">
      <input>
def update_weibull_incomplete(prior, data):
    &quot;&quot;&quot;Update the prior using incomplete data.&quot;&quot;&quot;
    lam_mesh, k_mesh, data_mesh = np.meshgrid(
        prior.columns, prior.index, data)
    
    # evaluate the survival function
    probs = weibull_dist(lam_mesh, k_mesh).sf(data_mesh)
    likelihood = probs.prod(axis=2)

    posterior = prior * likelihood
    normalize(posterior)

    return posterior
      </input>
    </program>
    <p>
      Here's the update with the incomplete data.
    </p>
    <program language="python">
      <input>
posterior2 = update_weibull_incomplete(posterior1, data2)
      </input>
    </program>
    <p>
      And here's what the joint posterior distribution looks like after both updates.
    </p>
    <program language="python">
      <input>
plot_contour(posterior2)
decorate(title='Posterior joint distribution, incomplete data')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_10b2d200.png" width="80%"/>
    <p>
      Compared to the previous contour plot, it looks like the range of likely values for <m>\lambda</m> is substantially wider. We can see that more clearly by looking at the marginal distributions.
    </p>
    <program language="python">
      <input>
posterior_lam2 = marginal(posterior2, 0)
posterior_k2 = marginal(posterior2, 1)
      </input>
    </program>
    <p>
      Here's the posterior marginal distribution for <m>\lambda</m> compared to the distribution we got using all complete data.
    </p>
    <program language="python">
      <input>
posterior_lam.plot(color='C5', label='All complete',
                   linestyle='dashed')
posterior_lam2.plot(color='C2', label='Some censored')

decorate(xlabel='lambda',
         ylabel='PDF', 
         title='Marginal posterior distribution of lambda')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_4159f140.png" width="80%"/>
    <p>
      The distribution with some incomplete data is substantially wider.
    </p>
    <p>
      As an aside, notice that the posterior distribution does not come all the way to 0 on the right side. That suggests that the range of the prior distribution is not wide enough to cover the most likely values for this parameter. If I were concerned about making this distribution more accurate, I would go back and run the update again with a wider prior.
    </p>
    <p>
      Here's the posterior marginal distribution for <m>k</m>:
    </p>
    <program language="python">
      <input>
posterior_k.plot(color='C5', label='All complete',
                   linestyle='dashed')
posterior_k2.plot(color='C12', label='Some censored')

decorate(xlabel='k',
         ylabel='PDF', 
         title='Posterior marginal distribution of k')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_1018e46b.png" width="80%"/>
    <p>
      In this example, the marginal distribution is shifted to the left when we have incomplete data, but it is not substantially wider.
    </p>
    <p>
      In summary, we have seen how to combine complete and incomplete data to estimate the parameters of a Weibull distribution, which is useful in many real-world scenarios where some of the data are censored.
    </p>
    <p>
      In general, the posterior distributions are wider when we have incomplete data, because less information leads to more uncertainty.
    </p>
    <p>
      This example is based on data I generated; in the next section we'll do a similar analysis with real data.
    </p>
  </section>

  <section xml:id="sec-light-bulbs">
    <title>Light Bulbs</title>

    <p>
      In 2007 <url href="https://www.researchgate.net/publication/225450325_Renewal_Rate_of_Filament_Lamps_Theory_and_Experiment">researchers ran an experiment</url> to characterize the distribution of lifetimes for light bulbs. Here is their description of the experiment:
    </p>
    <p>
      &gt; An assembly of 50 new Philips (India) lamps with the rating 40 W, 220 V (AC) was taken and installed in the horizontal orientation and uniformly distributed over a lab area 11 m x 7 m. &gt; &gt; The assembly was monitored at regular intervals of 12 h to look for failures. The instants of recorded failures were [recorded] and a total of 32 data points were obtained such that even the last bulb failed.
    </p>
    <program language="python">
      <input>
download('https://gist.github.com/epogrebnyak/7933e16c0ad215742c4c104be4fbdeb1/raw/c932bc5b6aa6317770c4cbf43eb591511fec08f9/lamps.csv')
      </input>
    </program>
    <p>
      We can load the data into a <c>DataFrame</c> like this:
    </p>
    <program language="python">
      <input>
df = pd.read_csv('lamps.csv', index_col=0)
df.head()
      </input>
    </program>
<pre>
h  f   K
i            
0    0  0  50
1  840  2  48
2  852  1  47
3  936  1  46
4  960  1  45
</pre>
    <p>
      Column <c>h</c> contains the times when bulbs failed in hours; Column <c>f</c> contains the number of bulbs that failed at each time. We can represent these values and frequencies using a <c>Pmf</c>, like this:
    </p>
    <program language="python">
      <input>
from empiricaldist import Pmf

pmf_bulb = Pmf(df['f'].to_numpy(), df['h'])
pmf_bulb.normalize()
      </input>
    </program>
<pre>
50
</pre>
    <p>
      Because of the design of this experiment, we can consider the data to be a representative sample from the distribution of lifetimes, at least for light bulbs that are lit continuously.
    </p>
    <p>
      The average lifetime is about 1400 h.
    </p>
    <program language="python">
      <input>
pmf_bulb.mean()
      </input>
    </program>
<pre>
1413.84
</pre>
    <p>
      Assuming that these data are well modeled by a Weibull distribution, let's estimate the parameters that fit the data. Again, I'll start with uniform priors for <m>\lambda</m> and <m>k</m>:
    </p>
    <program language="python">
      <input>
lams = np.linspace(1000, 2000, num=51)
prior_lam = make_uniform(lams, name='lambda')
      </input>
    </program>
    <program language="python">
      <input>
ks = np.linspace(1, 10, num=51)
prior_k = make_uniform(ks, name='k')
      </input>
    </program>
    <p>
      For this example, there are 51 values in the prior distribution, rather than the usual 101.  That's because we are going to use the posterior distributions to do some computationally-intensive calculations. They will run faster with fewer values, but the results will be less precise.
    </p>
    <p>
      As usual, we can use <c>make_joint</c> to make the prior joint distribution.
    </p>
    <program language="python">
      <input>
prior_bulb = make_joint(prior_lam, prior_k)
      </input>
    </program>
    <p>
      Although we have data for 50 light bulbs, there are only 32 unique lifetimes in the dataset.  For the update, it is convenient to express the data in the form of 50 lifetimes, with each lifetime repeated the given number of times. We can use <c>np.repeat</c> to transform the data.
    </p>
    <program language="python">
      <input>
data_bulb = np.repeat(df['h'], df['f'])
len(data_bulb)
      </input>
    </program>
<pre>
50
</pre>
    <p>
      Now we can use <c>update_weibull</c> to do the update.
    </p>
    <program language="python">
      <input>
posterior_bulb = update_weibull(prior_bulb, data_bulb)
      </input>
    </program>
    <p>
      Here's what the posterior joint distribution looks like:
    </p>
    <program language="python">
      <input>
plot_contour(posterior_bulb)
decorate(title='Joint posterior distribution, light bulbs')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_34fa3b95.png" width="80%"/>
    <p>
      To summarize this joint posterior distribution, we'll compute the posterior mean lifetime.
    </p>
  </section>

  <section xml:id="sec-posterior-means">
    <title>Posterior Means</title>

    <p>
      To compute the posterior mean of a joint distribution, we'll make a mesh that contains the values of <m>\lambda</m> and <m>k</m>.
    </p>
    <program language="python">
      <input>
lam_mesh, k_mesh = np.meshgrid(
    prior_bulb.columns, prior_bulb.index)
      </input>
    </program>
    <p>
      Now for each pair of parameters we'll use <c>weibull_dist</c> to compute the mean.
    </p>
    <program language="python">
      <input>
means = weibull_dist(lam_mesh, k_mesh).mean()
means.shape
      </input>
    </program>
<pre>
(51, 51)
</pre>
    <p>
      The result is an array with the same dimensions as the joint distribution.
    </p>
    <p>
      Now we need to weight each mean with the corresponding probability from the joint posterior.
    </p>
    <program language="python">
      <input>
prod = means * posterior_bulb
      </input>
    </program>
    <p>
      Finally we compute the sum of the weighted means.
    </p>
    <program language="python">
      <input>
prod.to_numpy().sum()
      </input>
    </program>
<pre>
1412.7242774305005
</pre>
    <p>
      Based on the posterior distribution, we think the mean lifetime is about 1413 hours.
    </p>
    <p>
      The following function encapsulates these steps:
    </p>
    <program language="python">
      <input>
def joint_weibull_mean(joint):
    &quot;&quot;&quot;Compute the mean of a joint distribution of Weibulls.&quot;&quot;&quot;
    lam_mesh, k_mesh = np.meshgrid(
        joint.columns, joint.index)
    means = weibull_dist(lam_mesh, k_mesh).mean()
    prod = means * joint
    return prod.to_numpy().sum()
      </input>
    </program>
  </section>

  <section xml:id="sec-incomplete-information">
    <title>Incomplete Information</title>

    <p>
      The previous update was not quite right, because it assumed each light bulb died at the instant we observed it. According to the report, the researchers only checked the bulbs every 12 hours.  So if they see that a bulb has died, they know only that it died during the 12 hours since the last check.
    </p>
    <p>
      It is more strictly correct to use the following update function, which uses the CDF of the Weibull distribution to compute the probability that a bulb dies during a given 12 hour interval.
    </p>
    <program language="python">
      <input>
def update_weibull_between(prior, data, dt=12):
    &quot;&quot;&quot;Update the prior based on data.&quot;&quot;&quot;
    lam_mesh, k_mesh, data_mesh = np.meshgrid(
        prior.columns, prior.index, data)
    dist = weibull_dist(lam_mesh, k_mesh)
    cdf1 = dist.cdf(data_mesh)
    cdf2 = dist.cdf(data_mesh-12)
    likelihood = (cdf1 - cdf2).prod(axis=2)

    posterior = prior * likelihood
    normalize(posterior)

    return posterior
      </input>
    </program>
    <p>
      The probability that a value falls in an interval is the difference between the CDF at the beginning and end of the interval.
    </p>
    <p>
      Here's how we run the update.
    </p>
    <program language="python">
      <input>
posterior_bulb2 = update_weibull_between(prior_bulb, data_bulb)
      </input>
    </program>
    <p>
      And here are the results.
    </p>
    <program language="python">
      <input>
plot_contour(posterior_bulb2)
decorate(title='Joint posterior distribution, light bulbs')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_7c747034.png" width="80%"/>
    <p>
      Visually this result is almost identical to what we got using the PDF. And that's good news, because it suggests that using the PDF can be a good approximation even if it's not strictly correct.
    </p>
    <p>
      To see whether it makes any difference at all, let's check the posterior means.
    </p>
    <program language="python">
      <input>
joint_weibull_mean(posterior_bulb)
      </input>
    </program>
<pre>
1412.7242774305005
</pre>
    <program language="python">
      <input>
joint_weibull_mean(posterior_bulb2)
      </input>
    </program>
<pre>
1406.8171982320873
</pre>
    <p>
      When we take into account the 12-hour interval between observations, the posterior mean is about 6 hours less. And that makes sense: if we assume that a bulb is equally likely to expire at any point in the interval, the average would be the midpoint of the interval.
    </p>
  </section>

  <section xml:id="sec-posterior-predictive-distribution">
    <title>Posterior Predictive Distribution</title>

    <p>
      Suppose you install 100 light bulbs of the kind in the previous section, and you come back to check on them after 1000 hours.  Based on the posterior distribution we just computed, what is the distribution of the number of bulbs you find dead?
    </p>
    <p>
      If we knew the parameters of the Weibull distribution for sure, the answer would be a binomial distribution.
    </p>
    <p>
      For example, if we know that <m>\lambda=1550</m> and <m>k=4.25</m>, we can use <c>weibull_dist</c> to compute the probability that a bulb dies before you return:
    </p>
    <program language="python">
      <input>
lam = 1550
k = 4.25
t = 1000

prob_dead = weibull_dist(lam, k).cdf(t)
prob_dead
      </input>
    </program>
<pre>
0.14381685899960547
</pre>
    <p>
      If there are 100 bulbs and each has this probability of dying, the number of dead bulbs follows a binomial distribution.
    </p>
    <program language="python">
      <input>
from utils import make_binomial

n = 100
p = prob_dead
dist_num_dead = make_binomial(n, p)
      </input>
    </program>
    <p>
      And here's what it looks like.
    </p>
    <program language="python">
      <input>
dist_num_dead.plot(label='known parameters')

decorate(xlabel='Number of dead bulbs',
         ylabel='PMF',
         title='Predictive distribution with known parameters')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_dcff7e90.png" width="80%"/>
    <p>
      But that's based on the assumption that we know <m>\lambda</m> and <m>k</m>, and we don't. Instead, we have a posterior distribution that contains possible values of these parameters and their probabilities.
    </p>
    <p>
      So the posterior predictive distribution is not a single binomial; instead it is a mixture of binomials, weighted with the posterior probabilities.
    </p>
    <p>
      We can use <c>make_mixture</c> to compute the posterior predictive distribution. It doesn't work with joint distributions, but we can convert the <c>DataFrame</c> that represents a joint distribution to a <c>Series</c>, like this:
    </p>
    <program language="python">
      <input>
posterior_series = posterior_bulb.stack()
posterior_series.head()
      </input>
    </program>
<pre>
k    lambda
1.0  1000.0    8.146763e-25
     1020.0    1.210486e-24
     1040.0    1.738327e-24
     1060.0    2.418201e-24
     1080.0    3.265549e-24
dtype: float64
</pre>
    <p>
      The result is a <c>Series</c> with a <c>MultiIndex</c> that contains two "levels": the first level contains the values of <c>k</c>; the second contains the values of <c>lam</c>.
    </p>
    <p>
      With the posterior in this form, we can iterate through the possible parameters and compute a predictive distribution for each pair.
    </p>
    <program language="python">
      <input>
pmf_seq = []
for (k, lam) in posterior_series.index:
    prob_dead = weibull_dist(lam, k).cdf(t)
    pmf = make_binomial(n, prob_dead)
    pmf_seq.append(pmf)
      </input>
    </program>
    <p>
      Now we can use <c>make_mixture</c>, passing as parameters the posterior probabilities in <c>posterior_series</c> and the sequence of binomial distributions in <c>pmf_seq</c>.
    </p>
    <program language="python">
      <input>
from utils import make_mixture

post_pred = make_mixture(posterior_series, pmf_seq)
      </input>
    </program>
    <p>
      Here's what the posterior predictive distribution looks like, compared to the binomial distribution we computed with known parameters.
    </p>
    <program language="python">
      <input>
dist_num_dead.plot(label='known parameters')
post_pred.plot(label='unknown parameters')
decorate(xlabel='Number of dead bulbs',
         ylabel='PMF',
         title='Posterior predictive distribution')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_a579cf92.png" width="80%"/>
    <p>
      The posterior predictive distribution is wider because it represents our uncertainty about the parameters as well as our uncertainty about the number of dead bulbs.
    </p>
  </section>

  <section xml:id="sec-ch14-summary">
    <title>Summary</title>

    <p>
      This chapter introduces survival analysis, which is used to answer questions about the time until an event, and the Weibull distribution, which is a good model for "lifetimes" (broadly interpreted) in a number of domains.
    </p>
    <p>
      We used joint distributions to represent prior probabilities for the parameters of the Weibull distribution, and we updated them three ways: knowing the exact duration of a lifetime, knowing a lower bound, and knowing that a lifetime fell in a given interval.
    </p>
    <p>
      These examples demonstrate a feature of Bayesian methods: they can be adapted to handle incomplete, or "censored", data with only small changes.  As an exercise, you'll have a chance to work with one more type of censored data, when we are given an upper bound on a lifetime.
    </p>
    <p>
      The methods in this chapter work with any distribution with two parameters. In the exercises, you'll have a chance to estimate the parameters of a two-parameter gamma distribution, which is used to describe a variety of natural phenomena.
    </p>
    <p>
      And in the next chapter we'll move on to models with three parameters!
    </p>
  </section>

  <section xml:id="sec-ch14-exercises">
    <title>Exercises</title>

    <exercise xml:id="ex-ch14-1">
      <title>Exercise 1</title>
      <statement>
    <p>
      Using data about the lifetimes of light bulbs, we computed the posterior distribution from the parameters of a Weibull distribution, <m>\lambda</m> and <m>k</m>, and the posterior predictive distribution for the number of dead bulbs, out of 100, after 1000 hours.
    </p>
    <p>
      Now suppose you do the experiment:  You install 100 light bulbs, come back after 1000 hours, and find 20 dead light bulbs. Update the posterior distribution based on this data. How much does it change the posterior mean?
    </p>
    <p>
      Suggestions:
    </p>
    <p>
      1. Use a mesh grid to compute the probability of finding a bulb dead after 1000 hours for each pair of parameters.
    </p>
    <p>
      2. For each of those probabilities, compute the likelihood of finding 20 dead bulbs out of 100.
    </p>
    <p>
      3. Use those likelihoods to update the posterior distribution.
    </p>
      </statement>
    <solution>
    <program language="python">
      <input>
t = 1000

lam_mesh, k_mesh = np.meshgrid(
    prior_bulb.columns, prior_bulb.index)
prob_dead = weibull_dist(lam_mesh, k_mesh).cdf(t)
prob_dead.shape
      </input>
    </program>
<pre>
(51, 51)
</pre>
    <program language="python">
      <input>
from scipy.stats import binom

k = 20
n = 100
likelihood = binom(n, prob_dead).pmf(k)
likelihood.shape
      </input>
    </program>
<pre>
(51, 51)
</pre>
    <program language="python">
      <input>
posterior_bulb3 = posterior_bulb * likelihood
normalize(posterior_bulb3)
plot_contour(posterior_bulb3)
decorate(title='Joint posterior distribution with k=20')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_2a33b7f2.png" width="80%"/>
    <program language="python">
      <input>
# Since there were more dead bulbs than expected,
# the posterior mean is a bit less after the update.

joint_weibull_mean(posterior_bulb3)
      </input>
    </program>
<pre>
1378.3949572816407
</pre>
    </solution>
    </exercise>

    <exercise xml:id="ex-ch14-2">
      <title>Exercise 2</title>
      <statement>
    <p>
      In this exercise, we'll use one month of data to estimate the parameters of a distribution that describes daily rainfall in Seattle. Then we'll compute the posterior predictive distribution for daily rainfall and use it to estimate the probability of a rare event, like more than 1.5 inches of rain in a day.
    </p>
    <p>
      According to hydrologists, the distribution of total daily rainfall (for days with rain) is well modeled by a two-parameter gamma distribution.
    </p>
    <p>
      When we worked with the one-parameter gamma distribution in &lt;&lt;_TheGammaDistribution&gt;&gt;, we used the Greek letter <m>\alpha</m> for the parameter.
    </p>
    <p>
      For the two-parameter gamma distribution, we will use <m>k</m> for the "shape parameter", which determines the shape of the distribution, and the Greek letter <m>\theta</m> or <c>theta</c> for the "scale parameter".
    </p>
    <p>
      The following function takes these parameters and returns a <c>gamma</c> object from SciPy.
    </p>
    <program language="python">
      <input>
import scipy.stats

def gamma_dist(k, theta):
    &quot;&quot;&quot;Makes a gamma object.
    
    k: shape parameter
    theta: scale parameter
    
    returns: gamma object
    &quot;&quot;&quot;
    return scipy.stats.gamma(k, scale=theta)
      </input>
    </program>
    <p>
      Now we need some data. The following cell downloads data I collected from the National Oceanic and Atmospheric Administration (<url href="http://www.ncdc.noaa.gov/cdo-web/search">NOAA</url>) for Seattle, Washington in May 2020.
    </p>
    <program language="python">
      <input>
# Load the data file

download('https://github.com/AllenDowney/ThinkBayes2/raw/master/data/2203951.csv')
      </input>
    </program>
    <p>
      Now we can load it into a <c>DataFrame</c>:
    </p>
    <program language="python">
      <input>
weather = pd.read_csv('2203951.csv')
weather.head()
      </input>
    </program>
<pre>
STATION                           NAME        DATE   AWND  PRCP  TMAX  \
0  USW00024233  SEATTLE TACOMA AIRPORT, WA US  2020-05-01   4.47  0.00    66   
1  USW00024233  SEATTLE TACOMA AIRPORT, WA US  2020-05-02   9.40  0.24    58   
2  USW00024233  SEATTLE TACOMA AIRPORT, WA US  2020-05-03  11.63  0.06    57   
3  USW00024233  SEATTLE TACOMA AIRPORT, WA US  2020-05-04   4.47  0.00    65   
4  USW00024233  SEATTLE TACOMA AIRPORT, WA US  2020-05-05   7.83  0.00    71   

   TMIN  WT01  WT03  WT08  
0    43   NaN   NaN   NaN  
1    47   1.0   NaN   NaN  
2    44   1.0   NaN   NaN  
3    39   NaN   NaN   NaN  
4    49   NaN   NaN   NaN
</pre>
    <p>
      I'll make a Boolean Series to indicate which days it rained.
    </p>
    <program language="python">
      <input>
rained = weather['PRCP'] &gt; 0
rained.sum()
      </input>
    </program>
    <p>
      And select the total rainfall on the days it rained.
    </p>
    <program language="python">
      <input>
prcp = weather.loc[rained, 'PRCP']
prcp.describe()
      </input>
    </program>
<pre>
count    14.000000
mean      0.222857
std       0.301060
min       0.010000
25%       0.052500
50%       0.110000
75%       0.225000
max       1.140000
Name: PRCP, dtype: float64
</pre>
    <p>
      Here's what the CDF of the data looks like.
    </p>
    <program language="python">
      <input>
cdf_data = Cdf.from_seq(prcp)
cdf_data.plot()
decorate(xlabel='Total rainfall (in)',
         ylabel='CDF',
         title='Distribution of rainfall on days it rained')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_4f4bbfff.png" width="80%"/>
    <p>
      The maximum is 1.14 inches of rain is one day. To estimate the probability of more than 1.5 inches, we need to extrapolate from the data we have, so our estimate will depend on whether the gamma distribution is really a good model.
    </p>
    <p>
      I suggest you proceed in the following steps:
    </p>
    <p>
      1. Construct a prior distribution for the parameters of the gamma distribution.  Note that <m>k</m> and <m>\theta</m> must be greater than 0.
    </p>
    <p>
      2. Use the observed rainfalls to update the distribution of parameters.
    </p>
    <p>
      3. Compute the posterior predictive distribution of rainfall, and use it to estimate the probability of getting more than 1.5 inches of rain in one day.
    </p>
      </statement>
    <solution>
    <program language="python">
      <input>
# I'll use the MLE parameters of the gamma distribution
# to help me choose priors

k_est, _, theta_est = scipy.stats.gamma.fit(prcp, floc=0)
k_est, theta_est
      </input>
    </program>
<pre>
(0.8898876017525283, 0.25043291132301665)
</pre>
    <program language="python">
      <input>
# I'll use uniform priors for the parameters.
# I chose the upper bounds by trial and error.

ks = np.linspace(0.01, 2, num=51)
prior_k = make_uniform(ks, name='k')
      </input>
    </program>
    <program language="python">
      <input>
thetas = np.linspace(0.01, 1.5, num=51)
prior_theta = make_uniform(thetas, name='theta')
      </input>
    </program>
    <program language="python">
      <input>
# Here's the joint prior

prior = make_joint(prior_k, prior_theta)
      </input>
    </program>
    <program language="python">
      <input>
# I'll use a grid to compute the densities

k_mesh, theta_mesh, data_mesh = np.meshgrid(
    prior.columns, prior.index, prcp)
      </input>
    </program>
    <program language="python">
      <input>
# Here's the 3-D array of densities

densities = gamma_dist(k_mesh, theta_mesh).pdf(data_mesh) 
densities.shape
      </input>
    </program>
<pre>
(51, 51, 14)
</pre>
    <program language="python">
      <input>
# Which we reduce by multiplying along axis 2

likelihood = densities.prod(axis=2)
likelihood.sum()
      </input>
    </program>
<pre>
150287.91980136465
</pre>
    <program language="python">
      <input>
# Now we can do the update in the usual way

posterior = prior * likelihood
normalize(posterior)
      </input>
    </program>
<pre>
57.780822684107896
</pre>
    <program language="python">
      <input>
# And here's what the posterior looks like

plot_contour(posterior)

decorate(title='Posterior distribution, parameters of a gamma distribution')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_93797323.png" width="80%"/>
    <program language="python">
      <input>
# I'll check the marginal distributions to make sure the
# range of the priors is wide enough

from utils import marginal

posterior_k = marginal(posterior, 0)
posterior_theta = marginal(posterior, 1)
      </input>
    </program>
    <program language="python">
      <input>
# The marginal distribution for k is close to 0 at both ends

posterior_k.plot(color='C4')
decorate(xlabel='k',
         ylabel='PDF', 
         title='Posterior marginal distribution of k')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_8550af5e.png" width="80%"/>
    <program language="python">
      <input>
posterior_k.mean(), posterior_k.credible_interval(0.9)
      </input>
    </program>
<pre>
(0.8437218523899558, array([0.4478, 1.3632]))
</pre>
    <program language="python">
      <input>
# Same with the marginal distribution of theta

posterior_theta.plot(color='C2')
decorate(xlabel='theta',
         ylabel='PDF', 
         title='Posterior marginal distribution of theta')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_86f4bd92.png" width="80%"/>
    <program language="python">
      <input>
posterior_theta.mean(), posterior_theta.credible_interval(0.9)
      </input>
    </program>
<pre>
(0.367761307460383, array([0.159 , 0.7848]))
</pre>
    <program language="python">
      <input>
# To compute the posterior predictive distribution,
# I'll stack the joint posterior to make a Series
# with a MultiIndex

posterior_series = posterior.stack()
posterior_series.head()
      </input>
    </program>
<pre>
theta  k     
0.01   0.0100    4.306265e-156
       0.0498    1.304069e-145
       0.0896    2.463890e-141
       0.1294    2.077828e-138
       0.1692    4.227218e-136
dtype: float64
</pre>
    <program language="python">
      <input>
# I'll extend the predictive distribution up to 2 inches

low, high = 0.01, 2
      </input>
    </program>
    <program language="python">
      <input>
# Now we can iterate through `posterior_series`
# and make a sequence of predictive Pmfs, one
# for each possible pair of parameters

from utils import pmf_from_dist

qs = np.linspace(low, high, num=101)
pmf_seq = []
for (theta, k) in posterior_series.index:
    dist = gamma_dist(k, theta)
    pmf = pmf_from_dist(dist, qs)
    pmf_seq.append(pmf)
      </input>
    </program>
    <program language="python">
      <input>
# And we can use `make_mixture` to make the posterior predictive
# distribution

post_pred = make_mixture(posterior_series, pmf_seq)
      </input>
    </program>
    <program language="python">
      <input>
# Here's what it looks like.

post_pred.make_cdf().plot(label='rainfall')
decorate(xlabel='Total rainfall (in)',
         ylabel='CDF',
         title='Posterior predictive distribution of rainfall')
      </input>
    </program>
    <image source="images/ch14_survival_analysis_e4697dcd.png" width="80%"/>
    <program language="python">
      <input>
# The probability of more than 1.5 inches of rain is small

cdf = post_pred.make_cdf()
p_gt = 1 - cdf(1.5)
p_gt
      </input>
    </program>
<pre>
0.00900003598887611
</pre>
    <program language="python">
      <input>
# So it's easier to interpret as the number of rainy
# days between events, on average

1 / p_gt
      </input>
    </program>
<pre>
111.11066680577532
</pre>
    </solution>
    </exercise>

    <p>
      <em>Think Bayes</em>, Second Edition
    </p>
    <p>
      Copyright 2020 Allen B. Downey
    </p>
    <p>
      License: <url href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</url>
    </p>
  </section>
</chapter>